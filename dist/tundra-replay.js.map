{"version":3,"sources":["../tundra-replay.js"],"names":["replayProfile","profileRequests","headersToOmit","reset","forEach","request","response","mock","url","opts","actualOpts","actualUrl","urlMatches","RegExp","test","bodyMatches","body","content","headersMatch","JSON","stringify","headers","methodMatches","method","status","statusCode","name","overwriteRoutes"],"mappings":";;;;;QAKgBA,a,GAAAA,a;;AALhB;;AACA;;;;AACA;;;;AACA;;;;;;AAEO,SAASA,aAAT,CAAuBC,eAAvB,EAAwCC,aAAxC,EAAuD;;AAE1D,wBAAUC,KAAV;;AAEAF,oBAAgBG,OAAhB,CAAwB,gBAAyB;AAAA,YAAvBC,OAAuB,QAAvBA,OAAuB;AAAA,YAAdC,QAAc,QAAdA,QAAc;;AAC7C,4BAAUC,IAAV,CAAe,UAACC,GAAD,EAAMC,IAAN,EAAe;;AAE1B,gBAAIC,aAAaD,OAAOA,IAAP,GAAcD,GAA/B;AACA,gBAAIG,YAAYF,OAAOD,GAAP,GAAaA,IAAIA,GAAjC;;AAEA,gBAAII,aAAa,IAAIC,MAAJ,4BAAoC,sBAAaR,QAAQG,GAArB,CAApC,QAAkE,GAAlE,EAAuEM,IAAvE,CAA4EH,SAA5E,CAAjB;AACA,gBAAII,cAAcL,aAAaA,WAAWM,IAAX,KAAoBX,QAAQY,OAAzC,GAAmD,IAArE;AACA,gBAAIC,eAAeR,aAAaS,KAAKC,SAAL,CAAe,sBAAKV,WAAWW,OAAhB,EAAyBnB,aAAzB,CAAf,MAA4DiB,KAAKC,SAAL,CAAe,sBAAKf,QAAQgB,OAAb,EAAsBnB,aAAtB,CAAf,CAAzE,GAAgI,IAAnJ;AACA,gBAAIoB,gBAAgBZ,aAAaA,WAAWa,MAAX,KAAsBlB,QAAQkB,MAA3C,GAAmD,IAAvE;;AAEA,mBAAOX,cAAcU,aAAd,IAA+BP,WAA/B,IAA8CG,YAArD;AACH,SAXD,EAWG;AACCF,kBAAMV,SAASW,OADhB;AAECI,qBAASf,SAASe,OAFnB;AAGCG,oBAAQlB,SAASmB;AAHlB,SAXH,EAeE;AACEC,kBAASrB,QAAQkB,MAAjB,SAA2BlB,QAAQG,GADrC;AAEEmB,6BAAiB;AAFnB,SAfF;AAmBH,KApBD;AAqBH","file":"tundra-replay.js","sourcesContent":["import 'url';\nimport fetchMock from 'fetch-mock';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport omit from 'lodash.omit';\n\nexport function replayProfile(profileRequests, headersToOmit) {\n\n    fetchMock.reset();\n\n    profileRequests.forEach(({request, response}) => {\n        fetchMock.mock((url, opts) => {\n\n            let actualOpts = opts ? opts : url;\n            let actualUrl = opts ? url : url.url;\n\n            let urlMatches = new RegExp(`^(https?://)?(www\\\\.)?${escapeRegExp(request.url)}$`, 'g').test(actualUrl);\n            let bodyMatches = actualOpts ? actualOpts.body === request.content : true;\n            let headersMatch = actualOpts ? JSON.stringify(omit(actualOpts.headers, headersToOmit)) === JSON.stringify(omit(request.headers, headersToOmit)) : true;\n            let methodMatches = actualOpts ? actualOpts.method === request.method: true;\n\n            return urlMatches && methodMatches && bodyMatches && headersMatch;\n        }, {\n            body: response.content,\n            headers: response.headers,\n            status: response.statusCode\n        },{\n            name: `${request.method} ${request.url}`,\n            overwriteRoutes: false\n        })\n    });\n}"]}