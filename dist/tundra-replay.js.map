{"version":3,"sources":["../tundra-replay.js"],"names":["replayProfile","WILDCARD_MARKER_ESCAPED","stringIsSimilarTo","source","target","wildcardedSource","replace","RegExp","isMatch","profileRequests","headersToOmit","reset","forEach","request","response","mock","url","opts","actualOpts","actualUrl","urlMatches","test","bodyMatches","content","body","headersMatch","JSON","stringify","headers","methodMatches","method","status","statusCode","name","overwriteRoutes"],"mappings":";;;;;QAsBgBA,a,GAAAA,a;;AAtBhB;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMC,0BAA0B,SAAhC;;AAEA,IAAMC,oBAAoB,SAApBA,iBAAoB,CAACC,MAAD,EAASC,MAAT,EAAoB;;AAE1C,QAAID,UAAUC,MAAd,EAAsB;AAClB,YAAIC,mBAAmBF,OAClBG,OADkB,CACV,IAAIC,MAAJ,CAAW,sBAAa,GAAb,CAAX,EAA8B,GAA9B,CADU,EAC0B,KAD1B,EAElBD,OAFkB,CAEV,IAAIC,MAAJ,CAAW,sBAAaN,uBAAb,CAAX,EAAkD,GAAlD,CAFU,EAE8C,GAF9C,CAAvB;;AAIA,eAAO,kBAAQO,OAAR,CAAgBJ,MAAhB,EAAwBC,gBAAxB,CAAP;AACH,KAND,MAOK;AACD,eAAOF,WAAWC,MAAlB;AACH;AACJ,CAZD;;AAcO,SAASJ,aAAT,CAAuBS,eAAvB,EAAwCC,aAAxC,EAAuD;;AAE1D,wBAAUC,KAAV;;AAEAF,oBAAgBG,OAAhB,CAAwB,gBAAyB;AAAA,YAAvBC,OAAuB,QAAvBA,OAAuB;AAAA,YAAdC,QAAc,QAAdA,QAAc;;AAC7C,4BAAUC,IAAV,CAAe,UAACC,GAAD,EAAMC,IAAN,EAAe;;AAE1B,gBAAIC,aAAaD,OAAOA,IAAP,GAAcD,GAA/B;AACA,gBAAIG,YAAYF,OAAOD,GAAP,GAAaA,IAAIA,GAAjC;;AAEA,gBAAII,aAAa,IAAIb,MAAJ,4BAAoC,sBAAaM,QAAQG,GAArB,CAApC,QAAkE,GAAlE,EAAuEK,IAAvE,CAA4EF,SAA5E,CAAjB;AACA,gBAAIG,cAAcJ,aAAahB,kBAAkBW,QAAQU,OAA1B,EAAmCL,WAAWM,IAA9C,CAAb,GAAmE,IAArF;AACA,gBAAIC,eAAeP,aAAaQ,KAAKC,SAAL,CAAe,sBAAKT,WAAWU,OAAhB,EAAyBlB,aAAzB,CAAf,MAA4DgB,KAAKC,SAAL,CAAe,sBAAKd,QAAQe,OAAb,EAAsBlB,aAAtB,CAAf,CAAzE,GAAgI,IAAnJ;AACA,gBAAImB,gBAAgBX,aAAaA,WAAWY,MAAX,KAAsBjB,QAAQiB,MAA3C,GAAmD,IAAvE;;AAEA,mBAAOV,cAAcS,aAAd,IAA+BP,WAA/B,IAA8CG,YAArD;AACH,SAXD,EAWG;AACCD,kBAAMV,SAASS,OADhB;AAECK,qBAASd,SAASc,OAFnB;AAGCG,oBAAQjB,SAASkB;AAHlB,SAXH,EAeE;AACEC,kBAASpB,QAAQiB,MAAjB,SAA2BjB,QAAQG,GADrC;AAEEkB,6BAAiB;AAFnB,SAfF;AAmBH,KApBD;AAqBH","file":"tundra-replay.js","sourcesContent":["import 'url';\nimport fetchMock from 'fetch-mock';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport omit from 'lodash.omit';\nimport matcher from \"matcher\";\n\nconst WILDCARD_MARKER_ESCAPED = '{{\\\\*}}';\n\nconst stringIsSimilarTo = (source, target) => {\n\n    if (source && target) {\n        let wildcardedSource = source\n            .replace(new RegExp(escapeRegExp('*'), 'g'), '\\\\*')\n            .replace(new RegExp(escapeRegExp(WILDCARD_MARKER_ESCAPED), 'g'), '*');\n\n        return matcher.isMatch(target, wildcardedSource);\n    }\n    else {\n        return source === target;\n    }\n};\n\nexport function replayProfile(profileRequests, headersToOmit) {\n\n    fetchMock.reset();\n\n    profileRequests.forEach(({request, response}) => {\n        fetchMock.mock((url, opts) => {\n\n            let actualOpts = opts ? opts : url;\n            let actualUrl = opts ? url : url.url;\n\n            let urlMatches = new RegExp(`^(https?://)?(www\\\\.)?${escapeRegExp(request.url)}$`, 'g').test(actualUrl);\n            let bodyMatches = actualOpts ? stringIsSimilarTo(request.content, actualOpts.body) : true;\n            let headersMatch = actualOpts ? JSON.stringify(omit(actualOpts.headers, headersToOmit)) === JSON.stringify(omit(request.headers, headersToOmit)) : true;\n            let methodMatches = actualOpts ? actualOpts.method === request.method: true;\n\n            return urlMatches && methodMatches && bodyMatches && headersMatch;\n        }, {\n            body: response.content,\n            headers: response.headers,\n            status: response.statusCode\n        },{\n            name: `${request.method} ${request.url}`,\n            overwriteRoutes: false\n        })\n    });\n}"]}