{"version":3,"sources":["../tundra-replay.js"],"names":["replayProfile","WILDCARD_MARKER_ESCAPED","stringIsSimilarTo","source","target","wildcardedSource","replace","RegExp","isMatch","profileRequests","headersToOmit","reset","forEach","request","response","mock","url","opts","actualOpts","actualUrl","actualOptsHeaders","JSON","stringify","headers","actualRequestHeaders","urlMatches","test","bodyMatches","content","body","headersMatch","methodMatches","method","status","statusCode","name","overwriteRoutes"],"mappings":";;;;;QAsBgBA,a,GAAAA,a;;AApBhB;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMC,0BAA0B,SAAhC,C,CARA;;AAUA,IAAMC,oBAAoB,SAApBA,iBAAoB,CAACC,MAAD,EAASC,MAAT,EAAoB;AAC5C,MAAID,UAAUC,MAAd,EAAsB;AACpB,QAAMC,mBAAmBF,OACtBG,OADsB,CACd,IAAIC,MAAJ,CAAW,sBAAa,GAAb,CAAX,EAA8B,GAA9B,CADc,EACsB,KADtB,EAEtBD,OAFsB,CAEd,IAAIC,MAAJ,CAAW,sBAAaN,uBAAb,CAAX,EAAkD,GAAlD,CAFc,EAE0C,GAF1C,CAAzB;;AAIA,WAAO,kBAAQO,OAAR,CAAgBJ,MAAhB,EAAwBC,gBAAxB,CAAP;AACD;;AAED,SAAOF,WAAWC,MAAlB;AACD,CAVD;;AAYO,SAASJ,aAAT,CAAuBS,eAAvB,EAAwCC,aAAxC,EAAuD;AAC5D,sBAAUC,KAAV;;AAEAF,kBAAgBG,OAAhB,CAAwB,gBAA2B;AAAA,QAAxBC,OAAwB,QAAxBA,OAAwB;AAAA,QAAfC,QAAe,QAAfA,QAAe;;AACjD,wBAAUC,IAAV,CAAe,UAACC,GAAD,EAAMC,IAAN,EAAe;AAC5B,UAAMC,aAAaD,QAAQD,GAA3B;AACA,UAAMG,YAAYF,OAAOD,GAAP,GAAaA,IAAIA,GAAnC;AACA,UAAMI,oBAAoBC,KAAKC,SAAL,CAAe,sBAAKJ,WAAWK,OAAhB,EAAyBb,aAAzB,CAAf,CAA1B;AACA,UAAMc,uBAAuBH,KAAKC,SAAL,CAAe,sBAAKT,QAAQU,OAAb,EAAsBb,aAAtB,CAAf,CAA7B;;AAEA,UAAMe,aAAa,IAAIlB,MAAJ,4BAAoC,sBAAaM,QAAQG,GAArB,CAApC,QAAkE,GAAlE,EAAuEU,IAAvE,CAA4EP,SAA5E,CAAnB;AACA,UAAMQ,cAAcT,aAAahB,kBAAkBW,QAAQe,OAA1B,EAAmCV,WAAWW,IAA9C,CAAb,GAAmE,IAAvF;AACA,UAAMC,eAAeZ,aAAaE,sBAAsBI,oBAAnC,GAA0D,IAA/E;AACA,UAAMO,gBAAgBb,aAAaA,WAAWc,MAAX,KAAsBnB,QAAQmB,MAA3C,GAAoD,IAA1E;;AAEA,aAAOP,cAAcM,aAAd,IAA+BJ,WAA/B,IAA8CG,YAArD;AACD,KAZD,EAYG;AACDD,YAAMf,SAASc,OADd;AAEDL,eAAST,SAASS,OAFjB;AAGDU,cAAQnB,SAASoB;AAHhB,KAZH,EAgBG;AACDC,YAAStB,QAAQmB,MAAjB,SAA2BnB,QAAQG,GADlC;AAEDoB,uBAAiB;AAFhB,KAhBH;AAoBD,GArBD;AAsBD","file":"tundra-replay.js","sourcesContent":["/* eslint-disable import/prefer-default-export */\n\nimport 'url';\nimport fetchMock from 'fetch-mock';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport omit from 'lodash.omit';\nimport matcher from 'matcher';\n\nconst WILDCARD_MARKER_ESCAPED = '{{\\\\*}}';\n\nconst stringIsSimilarTo = (source, target) => {\n  if (source && target) {\n    const wildcardedSource = source\n      .replace(new RegExp(escapeRegExp('*'), 'g'), '\\\\*')\n      .replace(new RegExp(escapeRegExp(WILDCARD_MARKER_ESCAPED), 'g'), '*');\n\n    return matcher.isMatch(target, wildcardedSource);\n  }\n\n  return source === target;\n};\n\nexport function replayProfile(profileRequests, headersToOmit) {\n  fetchMock.reset();\n\n  profileRequests.forEach(({ request, response }) => {\n    fetchMock.mock((url, opts) => {\n      const actualOpts = opts || url;\n      const actualUrl = opts ? url : url.url;\n      const actualOptsHeaders = JSON.stringify(omit(actualOpts.headers, headersToOmit));\n      const actualRequestHeaders = JSON.stringify(omit(request.headers, headersToOmit));\n\n      const urlMatches = new RegExp(`^(https?://)?(www\\\\.)?${escapeRegExp(request.url)}$`, 'g').test(actualUrl);\n      const bodyMatches = actualOpts ? stringIsSimilarTo(request.content, actualOpts.body) : true;\n      const headersMatch = actualOpts ? actualOptsHeaders === actualRequestHeaders : true;\n      const methodMatches = actualOpts ? actualOpts.method === request.method : true;\n\n      return urlMatches && methodMatches && bodyMatches && headersMatch;\n    }, {\n      body: response.content,\n      headers: response.headers,\n      status: response.statusCode,\n    }, {\n      name: `${request.method} ${request.url}`,\n      overwriteRoutes: false,\n    });\n  });\n}\n"]}