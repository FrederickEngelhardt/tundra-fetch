{"version":3,"sources":["../../src/replay.js"],"names":["matchingFunction","matchingConfig","request","response","_url","_config","url","config","headersToOmit","configHeaders","JSON","stringify","headers","requestHeaders","urlMatches","bodyMatches","content","body","headersMatch","methodMatches","method","everythingMatches","debuggingEnabled","builtRequest","debugPort","profileRequests","reset","repeatMap","forEach","requestRepeatMap","invocations","responseOptions","status","statusCode","mock","catch","args","fetchConfig","Error"],"mappings":"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","file":"replay.js","sourcesContent":["import 'url';\nimport fetchMock from 'fetch-mock';\nimport omit from 'lodash.omit';\nimport buildRequestId from './requestIdBuilder';\nimport stringIsSimilarTo from './stringSimilarity';\nimport buildFetchMockConfig from './fetchMockConfigBuilder';\nimport buildRequestRepeatMap from './requestRepeatMapBuilder';\nimport removeURLPrefix from './removeURLPrefix';\nimport extractFetchArguments from './fetchArgumentExtractor';\nimport buildRequest from './requestBuilder';\nimport submitRequestData from './submitRequest';\n\nexport const matchingFunction = (matchingConfig, request, response) => (_url, _config) => {\n  const { url, config } = extractFetchArguments([_url, _config]);\n  const headersToOmit = matchingConfig ? matchingConfig.headersToOmit : null;\n  const configHeaders = JSON.stringify(omit(config.headers, headersToOmit));\n  const requestHeaders = JSON.stringify(omit(request.headers, headersToOmit));\n\n  const urlMatches = stringIsSimilarTo(removeURLPrefix(request.url), removeURLPrefix(url));\n  const bodyMatches = config ? stringIsSimilarTo(request.content, config.body) : true;\n  const headersMatch = config ? stringIsSimilarTo(requestHeaders, configHeaders) : true;\n  const methodMatches = config ? config.method === request.method : true;\n\n  const everythingMatches = urlMatches && methodMatches && bodyMatches && headersMatch;\n\n  if (everythingMatches && matchingConfig.debuggingEnabled) {\n    const builtRequest = buildRequest(url, config, response, response.body);\n\n    submitRequestData(builtRequest, matchingConfig.debugPort, everythingMatches);\n  }\n\n  return everythingMatches;\n};\n\nexport default (profileRequests, config) => {\n  fetchMock.reset();\n\n  const repeatMap = buildRequestRepeatMap(profileRequests);\n\n  profileRequests.forEach(({ request, response }) => {\n    const requestRepeatMap = repeatMap[buildRequestId(request)];\n    requestRepeatMap.invocations += 1;\n\n    const responseOptions = {\n      body: response.content,\n      headers: response.headers,\n      status: response.statusCode,\n    };\n\n    fetchMock.mock(\n      matchingFunction(config, request, response),\n      responseOptions,\n      buildFetchMockConfig(request, config, repeatMap),\n    ).catch(async (...args) => {\n      const { url, config: fetchConfig } = extractFetchArguments(args);\n      const builtRequest = buildRequest(url, fetchConfig, null, null);\n\n      if (config.debuggingEnabled) {\n        await submitRequestData(builtRequest, config.debugPort, false);\n      }\n\n      throw Error('Unable to match request');\n    });\n  });\n};\n"]}