{"version":3,"sources":["../replay.js"],"names":["WILDCARD_MARKER_ESCAPED","stringIsSimilarTo","source","target","wildcardedSource","replace","RegExp","isMatch","buildRequestId","request","method","url","buildRequestRepeatMap","requests","repeatMap","forEach","requestId","repeated","invocations","buildFetchMockConfig","config","baseConfig","name","overwriteRoutes","repeatMode","toUpperCase","profileRequests","reset","response","requestRepeatMap","matchingFunction","opts","actualOpts","actualUrl","actualOptsHeaders","JSON","stringify","headers","headersToOmit","actualRequestHeaders","urlMatches","test","bodyMatches","content","body","headersMatch","methodMatches","responseOptions","status","statusCode","mock"],"mappings":"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","file":"replay.js","sourcesContent":["import 'url';\nimport fetchMock from 'fetch-mock';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport omit from 'lodash.omit';\nimport matcher from 'matcher';\n\nconst WILDCARD_MARKER_ESCAPED = '{{\\\\*}}';\n\nconst stringIsSimilarTo = (source, target) => {\n  if (source && target) {\n    const wildcardedSource = source\n      .replace(new RegExp(escapeRegExp('*'), 'g'), '\\\\*')\n      .replace(new RegExp(escapeRegExp(WILDCARD_MARKER_ESCAPED), 'g'), '*');\n\n    return matcher.isMatch(target, wildcardedSource);\n  }\n\n  return source === target;\n};\n\nconst buildRequestId = (request) => {\n  return `${request.method} ${request.url}`;\n};\n\nconst buildRequestRepeatMap = (requests) => {\n  let repeatMap = [];\n\n  requests.forEach(({request}) => {\n    const requestId = buildRequestId(request);\n\n    if (requestId in repeatMap) {\n      repeatMap[requestId].repeated += 1;\n    }\n    else {\n      repeatMap[requestId] = {\n        repeated: 1,\n        invocations: 0,\n      }\n    }\n  });\n\n  return repeatMap;\n};\n\nconst buildFetchMockConfig = (request, config, repeatMap) => {\n  const baseConfig = {\n    name: buildRequestId(request),\n    overwriteRoutes: false,\n  };\n\n  const repeatMode = config.repeatMode && config.repeatMode.toUpperCase();\n\n  if (repeatMode === 'FIRST') {\n    return baseConfig;\n  }\n  else {\n    const { invocations, repeated } = repeatMap[buildRequestId(request)];\n\n    if (invocations >= repeated) {\n      if (repeatMode === 'LAST') {\n        return baseConfig;\n      }\n    }\n\n    baseConfig['repeat'] = 1;\n\n    return baseConfig;\n  }\n};\n\nexport default (profileRequests, config) => {\n  fetchMock.reset();\n\n  const repeatMap = buildRequestRepeatMap(profileRequests);\n\n  profileRequests.forEach(({request, response}) => {\n    const requestRepeatMap = repeatMap[buildRequestId(request)];\n    requestRepeatMap.invocations += 1;\n\n    const matchingFunction = (url, opts) => {\n      const actualOpts = opts || url;\n      const actualUrl = opts ? url : url.url;\n      const actualOptsHeaders = JSON.stringify(omit(actualOpts.headers, config.headersToOmit));\n      const actualRequestHeaders = JSON.stringify(omit(request.headers, config.headersToOmit));\n\n      const urlMatches = new RegExp(`^(https?://)?(www\\\\.)?${escapeRegExp(request.url)}$`, 'g').test(actualUrl);\n      const bodyMatches = actualOpts ? stringIsSimilarTo(request.content, actualOpts.body) : true;\n      const headersMatch = actualOpts ? actualOptsHeaders === actualRequestHeaders : true;\n      const methodMatches = actualOpts ? actualOpts.method === request.method : true;\n\n      return urlMatches && methodMatches && bodyMatches && headersMatch;\n    };\n\n    const responseOptions = {\n      body: response.content,\n      headers: response.headers,\n      status: response.statusCode,\n    };\n\n    fetchMock.mock(\n      matchingFunction,\n      responseOptions,\n      buildFetchMockConfig(request, config, repeatMap),\n    );\n  });\n};\n"]}