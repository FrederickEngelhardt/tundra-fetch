{"version":3,"sources":["../replay.js"],"names":["WILDCARD_MARKER_ESCAPED","stringIsSimilarTo","source","target","wildcardedSource","replace","RegExp","isMatch","buildRequestId","value","request","method","JSON","stringify","headers","url","buildRequestRepeatMap","requests","repeatMap","forEach","requestId","repeated","invocations","buildFetchMockConfig","config","baseConfig","name","overwriteRoutes","repeatMode","toUpperCase","repeat","profileRequests","reset","response","requestRepeatMap","matchingFunction","opts","actualOpts","actualUrl","actualOptsHeaders","headersToOmit","actualRequestHeaders","urlMatches","test","bodyMatches","content","body","headersMatch","methodMatches","responseOptions","status","statusCode","mock"],"mappings":"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","file":"replay.js","sourcesContent":["import 'url';\nimport fetchMock from 'fetch-mock';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport omit from 'lodash.omit';\nimport matcher from 'matcher';\nimport { hashCode } from 'hashcode';\n\nconst WILDCARD_MARKER_ESCAPED = '{{\\\\*}}';\n\nconst stringIsSimilarTo = (source, target) => {\n  if (source && target) {\n    const wildcardedSource = source\n      .replace(new RegExp(escapeRegExp('*'), 'g'), '\\\\*')\n      .replace(new RegExp(escapeRegExp(WILDCARD_MARKER_ESCAPED), 'g'), '*');\n\n    return matcher.isMatch(target, wildcardedSource);\n  }\n\n  return source === target;\n};\n\nconst buildRequestId = request => hashCode().value(`${request.method} ${JSON.stringify(request.headers)} ${request.url}`);\n\nconst buildRequestRepeatMap = (requests) => {\n  const repeatMap = [];\n\n  requests.forEach(({ request }) => {\n    const requestId = buildRequestId(request);\n\n    if (requestId in repeatMap) {\n      repeatMap[requestId].repeated += 1;\n    } else {\n      repeatMap[requestId] = {\n        repeated: 1,\n        invocations: 0,\n      };\n    }\n  });\n\n  return repeatMap;\n};\n\nconst buildFetchMockConfig = (request, config, repeatMap) => {\n  const baseConfig = {\n    name: buildRequestId(request),\n    overwriteRoutes: false,\n  };\n\n  const repeatMode = config.repeatMode && config.repeatMode.toUpperCase();\n\n  if (repeatMode === 'FIRST') {\n    return baseConfig;\n  }\n\n  const { invocations, repeated } = repeatMap[buildRequestId(request)];\n\n  if (invocations >= repeated) {\n    if (repeatMode === 'LAST') {\n      return baseConfig;\n    }\n  }\n\n  baseConfig.repeat = 1;\n\n  return baseConfig;\n};\n\nexport default (profileRequests, config) => {\n  fetchMock.reset();\n\n  const repeatMap = buildRequestRepeatMap(profileRequests);\n\n  profileRequests.forEach(({ request, response }) => {\n    const requestRepeatMap = repeatMap[buildRequestId(request)];\n    requestRepeatMap.invocations += 1;\n\n    const matchingFunction = (url, opts) => {\n      const actualOpts = opts || url;\n      const actualUrl = opts ? url : url.url;\n      const actualOptsHeaders = JSON.stringify(omit(actualOpts.headers, config.headersToOmit));\n      const actualRequestHeaders = JSON.stringify(omit(request.headers, config.headersToOmit));\n\n      const urlMatches = new RegExp(`^(https?://)?(www\\\\.)?${escapeRegExp(request.url)}$`, 'g').test(actualUrl);\n      const bodyMatches = actualOpts ? stringIsSimilarTo(request.content, actualOpts.body) : true;\n      const headersMatch = actualOpts ? actualOptsHeaders === actualRequestHeaders : true;\n      const methodMatches = actualOpts ? actualOpts.method === request.method : true;\n\n      return urlMatches && methodMatches && bodyMatches && headersMatch;\n    };\n\n    const responseOptions = {\n      body: response.content,\n      headers: response.headers,\n      status: response.statusCode,\n    };\n\n    fetchMock.mock(\n      matchingFunction,\n      responseOptions,\n      buildFetchMockConfig(request, config, repeatMap),\n    );\n  });\n};\n"]}