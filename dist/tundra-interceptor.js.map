{"version":3,"sources":["../tundra-interceptor.js"],"names":["_fetch","requestURL","requestConfig","response","responseBody","port","capturedRequest","request","url","headers","undefined","method","content","body","map","statusCode","status","XMLHttpRequest","open","setRequestHeader","send","JSON","stringify","submitRequestData","interceptFetchCalls","global","fetch","config","apply","arguments","then","data","clone","json","console","log"],"mappings":";;;;;;;wEAiBA,kBAAiCA,MAAjC,EAAyCC,UAAzC,EAAqDC,aAArD,EAAoEC,QAApE,EAA8EC,YAA9E,EAA4FC,IAA5F;AAAA;AAAA;AAAA;AAAA;AAAA;AAEUC,uCAFV,GAE4B;AACpBC,qCAAS;AACLC,qCAAKP,UADA;AAELQ,yCAASP,gBAAgBA,cAAcO,OAA9B,GAAwCC,SAF5C;AAGLC,wCAAQT,gBAAgBA,cAAcS,MAA9B,GAAuC,KAH1C;AAILC,yCAASV,gBAAgBA,cAAcW,IAA9B,GAAqCH;AAJzC,6BADW;AAOpBP,sCAAU;AACNM,yCAASN,SAASM,OAAT,CAAiBK,GADpB;AAENC,4CAAYZ,SAASa,MAFf;AAGNJ,yCAASR;AAHH;AAPU,yBAF5B;;AAgBI;AACA;;AACMG,+BAlBV,GAkBoB,IAAIU,cAAJ,EAlBpB;;;AAoBIV,gCAAQW,IAAR,CAAa,MAAb,wBAAyCb,IAAzC;AACAE,gCAAQY,gBAAR,CAAyB,cAAzB,EAAyC,kBAAzC;AACAZ,gCAAQa,IAAR,CAAaC,KAAKC,SAAL,CAAehB,eAAf,CAAb;;AAtBJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;oBAAeiB,iB;;;;;QAjBCC,mB,GAAAA,mB;;;;AAAT,SAASA,mBAAT,CAA6BnB,IAA7B,EAAmC;AACtC,QAAIL,SAASyB,OAAOC,KAApB;AACAD,WAAOC,KAAP,GAAe,UAASlB,GAAT,EAAcmB,MAAd,EAAsB;AACjC,eAAO3B,OAAO4B,KAAP,CAAa,IAAb,EAAmBC,SAAnB,EAA8BC,IAA9B;AAAA,+EAAmC,iBAAeC,IAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uCAEPA,KAAKC,KAAL,GAAaC,IAAb,EAFO;;AAAA;AAE5B7B,4CAF4B;AAAA;AAAA,uCAG5BmB,kBAAkBvB,MAAlB,EAA0BQ,GAA1B,EAA+BmB,MAA/B,EAAuCI,IAAvC,EAA6C3B,YAA7C,EAA2DC,IAA3D,CAH4B;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKlC6B,wCAAQC,GAAR,CAAY,iCAAZ;AACAD,wCAAQC,GAAR;;AANkC;AAAA,iEAS/BJ,IAT+B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAnC;;AAAA;AAAA;AAAA;AAAA,YAAP;AAWH,KAZD;AAaH","file":"tundra-interceptor.js","sourcesContent":["export function interceptFetchCalls(port) {\n    let _fetch = global.fetch;\n    global.fetch = function(url, config) {\n        return _fetch.apply(this, arguments).then(async function(data) {\n            try {\n                const responseBody = await data.clone().json();\n                await submitRequestData(_fetch, url, config, data, responseBody, port);\n            } catch (error) {\n                console.log('Error wiretapping fetch request');\n                console.log(error);\n            }\n\n            return data;\n        });\n    };\n}\n\nasync function submitRequestData(_fetch, requestURL, requestConfig, response, responseBody, port) {\n\n    const capturedRequest = {\n        request: {\n            url: requestURL,\n            headers: requestConfig ? requestConfig.headers : undefined,\n            method: requestConfig ? requestConfig.method : 'GET',\n            content: requestConfig ? requestConfig.body : undefined\n        },\n        response: {\n            headers: response.headers.map,\n            statusCode: response.status,\n            content: responseBody\n        }\n    };\n\n    // Using XMLHttpRequest to not interfere with the overwritten fetch object.\n    // Sending in a fire-and-forget fashion.\n    const request = new XMLHttpRequest();\n\n    request.open('POST', `http://localhost:${port}/requests`);\n    request.setRequestHeader('Content-Type', 'application/json');\n    request.send(JSON.stringify(capturedRequest));\n}"]}