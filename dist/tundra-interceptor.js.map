{"version":3,"sources":["../tundra-interceptor.js"],"names":["_fetch","requestURL","requestConfig","response","responseBody","port","capturedRequest","request","url","headers","undefined","method","content","body","map","statusCode","status","XMLHttpRequest","open","setRequestHeader","send","JSON","stringify","submitRequestData","interceptFetchCalls","originalfetch","global","fetch","config","actualUrl","actualConfig","apply","then","data","clone","json","console","error"],"mappings":";;;;;;AAAA;;;qEAEA,iBAAiCA,MAAjC,EAAyCC,UAAzC,EAAqDC,aAArD,EAAoEC,QAApE,EAA8EC,YAA9E,EAA4FC,IAA5F;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,2BADR,GAC0B;AACtBC,uBAAS;AACPC,qBAAKP,UADE;AAEPQ,yBAASP,gBAAgBA,cAAcO,OAA9B,GAAwCC,SAF1C;AAGPC,wBAAQT,gBAAgBA,cAAcS,MAA9B,GAAuC,KAHxC;AAIPC,yBAASV,gBAAgBA,cAAcW,IAA9B,GAAqCH;AAJvC,eADa;AAOtBP,wBAAU;AACRM,yBAASN,SAASM,OAAT,CAAiBK,GADlB;AAERC,4BAAYZ,SAASa,MAFb;AAGRJ,yBAASR;AAHD;AAPY,aAD1B;;AAeE;AACA;;AACMG,mBAjBR,GAiBkB,IAAIU,cAAJ,EAjBlB,EAiBwC;;AAEtCV,oBAAQW,IAAR,CAAa,MAAb,wBAAyCb,IAAzC;AACAE,oBAAQY,gBAAR,CAAyB,cAAzB,EAAyC,kBAAzC;AACAZ,oBAAQa,IAAR,CAAaC,KAAKC,SAAL,CAAehB,eAAf,CAAb;;AArBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeiB,iB;;;;;QAwBCC,mB,GAAAA,mB;;;;AAAT,SAASA,mBAAT,CAA6BnB,IAA7B,EAAmC;AAAA;;AACxC,MAAMoB,gBAAgBC,OAAOC,KAA7B;AACAD,SAAOC,KAAP,GAAe,UAACnB,GAAD,EAAMoB,MAAN,EAAiB;AAC9B;AACA,QAAMC,YAAYD,SAASpB,GAAT,GAAeA,IAAIA,GAArC;AACA,QAAMsB,eAAeF,UAAUpB,GAA/B;;AAEA,WAAOiB,cAAcM,KAAd,QAA0BC,IAA1B;AAAA,0EAA+B,kBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAEPA,KAAKC,KAAL,GAAaC,IAAb,EAFO;;AAAA;AAE5B/B,4BAF4B;AAAA;AAAA,uBAG5BmB,kBAAkBE,aAAlB,EAAiCI,SAAjC,EAA4CC,YAA5C,EAA0DG,IAA1D,EAAgE7B,YAAhE,EAA8EC,IAA9E,CAH4B;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKlC+B,wBAAQC,KAAR,CAAc,iCAAd;AACAD,wBAAQC,KAAR;;AANkC;AAAA,kDAS7BJ,IAT6B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAA/B;;AAAA;AAAA;AAAA;AAAA,QAAP;AAWD,GAhBD;AAiBD","file":"tundra-interceptor.js","sourcesContent":["/* eslint-disable import/prefer-default-export */\n\nasync function submitRequestData(_fetch, requestURL, requestConfig, response, responseBody, port) {\n  const capturedRequest = {\n    request: {\n      url: requestURL,\n      headers: requestConfig ? requestConfig.headers : undefined,\n      method: requestConfig ? requestConfig.method : 'GET',\n      content: requestConfig ? requestConfig.body : undefined,\n    },\n    response: {\n      headers: response.headers.map,\n      statusCode: response.status,\n      content: responseBody,\n    },\n  };\n\n  // Using XMLHttpRequest to not interfere with the overwritten fetch object.\n  // Sending in a fire-and-forget fashion.\n  const request = new XMLHttpRequest(); // eslint-disable-line no-undef\n\n  request.open('POST', `http://localhost:${port}/requests`);\n  request.setRequestHeader('Content-Type', 'application/json');\n  request.send(JSON.stringify(capturedRequest));\n}\n\nexport function interceptFetchCalls(port) {\n  const originalfetch = global.fetch;\n  global.fetch = (url, config) => {\n    // This accounts for times when fetch is called with just the configuration - e.g. fetch(config)\n    const actualUrl = config ? url : url.url;\n    const actualConfig = config || url;\n\n    return originalfetch.apply(this).then(async (data) => {\n      try {\n        const responseBody = await data.clone().json();\n        await submitRequestData(originalfetch, actualUrl, actualConfig, data, responseBody, port);\n      } catch (error) {\n        console.error('Error wiretapping fetch request');\n        console.error(error);\n      }\n\n      return data;\n    });\n  };\n}\n"]}