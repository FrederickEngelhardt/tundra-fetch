{"version":3,"sources":["../intercept.js"],"names":["_fetch","requestURL","requestConfig","response","responseBody","port","capturedRequest","request","url","headers","undefined","method","content","body","map","statusCode","status","XMLHttpRequest","open","setRequestHeader","send","JSON","stringify","submitRequestData","originalfetch","global","fetch","config","actualUrl","actualConfig","apply","arguments","then","data","clone","json","console","error"],"mappings":";;;;;;;qEAAA,iBAAiCA,MAAjC,EAAyCC,UAAzC,EAAqDC,aAArD,EAAoEC,QAApE,EAA8EC,YAA9E,EAA4FC,IAA5F;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,2BADR,GAC0B;AACtBC,uBAAS;AACPC,qBAAKP,UADE;AAEPQ,yBAASP,gBAAgBA,cAAcO,OAA9B,GAAwCC,SAF1C;AAGPC,wBAAQT,gBAAgBA,cAAcS,MAA9B,GAAuC,KAHxC;AAIPC,yBAASV,gBAAgBA,cAAcW,IAA9B,GAAqCH;AAJvC,eADa;AAOtBP,wBAAU;AACRM,yBAASN,SAASM,OAAT,CAAiBK,GADlB;AAERC,4BAAYZ,SAASa,MAFb;AAGRJ,yBAASR;AAHD;AAPY,aAD1B;;AAeE;AACA;;AACMG,mBAjBR,GAiBkB,IAAIU,cAAJ,EAjBlB,EAiBwC;;AAEtCV,oBAAQW,IAAR,CAAa,MAAb,wBAAyCb,IAAzC;AACAE,oBAAQY,gBAAR,CAAyB,cAAzB,EAAyC,kBAAzC;AACAZ,oBAAQa,IAAR,CAAaC,KAAKC,SAAL,CAAehB,eAAf,CAAb;;AArBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeiB,iB;;;;;;;kBAwBA,UAAClB,IAAD,EAAU;AACvB,MAAMmB,gBAAgBC,OAAOC,KAA7B;AACAD,SAAOC,KAAP,GAAe,UAAUlB,GAAV,EAAemB,MAAf,EAAuB;AAAA;;AACpC;AACA,QAAMC,YAAYD,SAASnB,GAAT,GAAeA,IAAIA,GAArC;AACA,QAAMqB,eAAeF,UAAUnB,GAA/B;;AAEA,WAAOgB,cAAcM,KAAd,CAAoB,IAApB,EAA0BC,SAA1B,EAAqCC,IAArC;AAAA,0EAA0C,kBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAElBA,KAAKC,KAAL,GAAaC,IAAb,EAFkB;;AAAA;AAEvC/B,4BAFuC;AAAA;AAAA,uBAGvCmB,kBAAkBC,aAAlB,EAAiCI,SAAjC,EAA4CC,YAA5C,EAA0DI,IAA1D,EAAgE7B,YAAhE,EAA8EC,IAA9E,CAHuC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAK7C+B,wBAAQC,KAAR,CAAc,iCAAd;AACAD,wBAAQC,KAAR;;AAN6C;AAAA,kDASxCJ,IATwC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAA1C;;AAAA;AAAA;AAAA;AAAA,QAAP;AAWD,GAhBD;AAiBD,C","file":"intercept.js","sourcesContent":["async function submitRequestData(_fetch, requestURL, requestConfig, response, responseBody, port) {\n  const capturedRequest = {\n    request: {\n      url: requestURL,\n      headers: requestConfig ? requestConfig.headers : undefined,\n      method: requestConfig ? requestConfig.method : 'GET',\n      content: requestConfig ? requestConfig.body : undefined,\n    },\n    response: {\n      headers: response.headers.map,\n      statusCode: response.status,\n      content: responseBody,\n    },\n  };\n\n  // Using XMLHttpRequest to not interfere with the overwritten fetch object.\n  // Sending in a fire-and-forget fashion.\n  const request = new XMLHttpRequest(); // eslint-disable-line no-undef\n\n  request.open('POST', `http://localhost:${port}/requests`);\n  request.setRequestHeader('Content-Type', 'application/json');\n  request.send(JSON.stringify(capturedRequest));\n}\n\nexport default (port) => {\n  const originalfetch = global.fetch;\n  global.fetch = function (url, config) {\n    // This accounts for times when fetch is called with just the configuration - e.g. fetch(config)\n    const actualUrl = config ? url : url.url;\n    const actualConfig = config || url;\n\n    return originalfetch.apply(this, arguments).then(async (data) => { // eslint-disable-line prefer-rest-params\n      try {\n        const responseBody = await data.clone().json();\n        await submitRequestData(originalfetch, actualUrl, actualConfig, data, responseBody, port);\n      } catch (error) {\n        console.error('Error wiretapping fetch request');\n        console.error(error);\n      }\n\n      return data;\n    });\n  };\n};\n"]}